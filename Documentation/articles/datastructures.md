# Data Structures

**LibLangly** is largely designed around efficient data structures and transformations of them. As such, it's important to have a very rich library of implementated data structures, and an efficient framework for creation of data structures.

Accomplishing this requires a number of careful design decisions that are quite unconventional, but highly effective. Of critical importance is a rich trait API that allows for data structure definitions to have a number of operations defined for them. This allows for minimal effort needing to be put in for maximum features. It also ensures every data structure with that trait has a consistent interface for that operation. Better orthogonality leads to better comprehension in line with the [Principal of Least Astonishment](https://en.wikipedia.org/wiki/Principle_of_least_astonishment). Careful use of inheritance versus traits allows for a high degree of code sharing and code generalization without creating the false assumption problem most collections libraries suffer from. Furthermore, deliberate use of CRTP allows for framework types to define large amounts of functionality for their derived classes, further reducing the burden for defining new data structures.

Complete, ready to use, data structures are always in decendant namespaces of `Langly.DataStructures` based on the broad category it belongs to.

Framework types are split into two broad categories. The base framework types are present in `Langly.DataStructures` and provides the absolute fundamentals of any data structure, and no more than that. This is also where all the data structure traits are located. The two, combined, are what gets around the false assumption problem others make. Similarly to complete data structures, more specialized framework types also live inside of the decendant namespaces. These are typically what you want to use when defining new data structures, or programming against them. For example, something that needs to work with lists isn't likely to care specifically whether it's singly or doubly linked, S-linked, a skip list, a partially unrolled list, or other options. However, more often than not, a function can simply depend on a trait, and work across many data structure classes.

Every framework type, and ideally every complete data structure, has both a standard and associative variant. Associativity is sometimes provided through things like key-value pairs or "dictionaries", although often these are specific types, not a variation of existing structures. The term "dictionary" is avoided, as **LibLangly** specializes around text processing applications, where there's an actual proper Dictionary type, keyed by textual elements. These associative variants are distinguished by having a generic parameter of `TIndex` which always comes first. Otherwise, they are referred to the same way. These can be used in any key-value situation, including sparse arrays.

## DataStructure

**Langly** uses a redefined core for its data structures, meant to address several concerns with .NET's. Luckily, you can tie directly into this core. [`DataStructure<TElement, TSelf, TEnumerator>`](https://entomy.github.io/LibLangly/api/Langly.DataStructures.DataStructure-3.html) forms the base of all standard data structures, while [`DataStructure<TIndex, TElement, TSelf, TEnumerator>`](https://entomy.github.io/LibLangly/api/Langly.DataStructures.DataStructure-4.html) forms the base of all associative data structures.

When deriving from either, a few extra things need to be defined. These have all been made `abstract` even if they weren't already, so an IDE will prompt you to define these and create stubs for you. If `TEnumerator` is not a predefined enumerator, you will need to provide your own implementation. It is advised to derive from [`IEnumerator<TElement>`](https://entomy.github.io/LibLangly/api/Langly.IEnumerator-1.html) or [`IEnumeratorBidi<TElement>`](https://entomy.github.io/LibLangly/api/Langly.IEnumeratorBidi-1.html) on a `struct`, not a `class`. This is not a hard requirement however.