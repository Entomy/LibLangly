# Patterns

**LibLangly** works through two layers. **Stringier.Patterns** is the pattern combinator and parsing framework, and **Langly**, the assembly, takes the parsing framework and puts the parsed text into a fully formed parse tree. This article covers the former, base layer.

**Stringier.Patterns** ressurects the extremely powerful but forgotten style of parsing from SNOBOL and UNICON, as a library that existing languages can use, rather than needing to learn an entirely new language. This addresses one of the biggest issues SNOBOL had, and why RegEx became so dominant: it was difficult to integrate and required SNOBOL be a complete language. Parsing frameworks havr come a very long way since then, so **Stringier.Patterns** doesn't keep 100% true to the SNOBOL model, instead taking additional inspiration from the advancements in RegEx engines, parser combinators, parser generators, and string scanners.

Conceptually, pattern combinators are very similar to parser combinators, as both are built upon combinator theory. The key difference is in the semantics. Parser combinators are built up using functions that explicitly dictate how parsing occurs. Pattern combinators, however, are completely declarative, stating what to parse, not how to parse it. This has two major effects. First is that as a user of the framework, you do not need to know what the most optimal way to parse something is, only what makes up a match. Second is that, because its truely declarative, internally rewriting patterns is possible as an optimization, just like how compilers rewrite code that has the same outcome, but done more efficiently. These two effects work together to create a framework that only requires describing what a successful match looks like; everything else is taken care of for you.