# Philosoft

**Philosoft** was split off at this point from some techniques that were used to help with developing **Collectathon** when I got some feedback about certain techniques being useful for developing non-collections. Originally it was a set of general interfaces, similar in nature to those in .NET's standard library. In time these interfaces would change and split into two varients, the Traits API and the Concepts API, inspired by the similarly named ideas from C++, within the limitations of C#.

The Traits API is a set of extremely granular and minimal interfaces that indicate support for a single property or method, and possibly overloads of that method. While nothing is stopping you from defining these yourself, using the Traits API ensures a consistent design is communicated throughout large projects, and enables generalization of functions across a wide variety of types. Furthermore, documentation for this functionality can be inherited from the interfaces, meaning docs can be kept consistent and meaningful, with as little effort as possible.

The Concepts API links multiple traits together in common patterns, more similar to the .NET collection interfaces, although it includes more, and isn't exclusive to collections. It also greatly modernizes these. Typically, these are a convenience to type designers, and should not be used as parameters to functions. Although there are exceptions. Using these when appropriate will ensure all relevant traits are supported. Do note that not all traits are wrapped up into concepts, especially as concepts are kept rather minimal, so you will likely need to include some additional traits when defining complex types like data structures.

Both of these are additionally used to define a rich set of extensions that further enhance the developer experience. In their most basic form this is convenience methods, like if your type supports `Add(TElement)` you'll get additional extensions for adding entire arrays, spans, enumerables, and more; but only one element at a time. Many traits support additional derivations for these as well, so if your type can have entire groups of elements added in one operation, consider adding these traits and providing optimized operations. These APIs are designed to support this, and callers will prefer the optimized operations instead of the convenience ones. These extensions aren't limited to just generalized implementations though, as many of them are entirely new operations that you never need to implement. They _just work_! No Todd Howarding going on here. In some cases more optimal LINQ methods will be provided that are compatible with LINQ standards. In this case, the specializations will be chosen and you won't need to change a thing.

As things progressed further, I recognized there was more need for basic developer conveniences. This is when **Philosoft** became a key library rather than just a simple offshoot. The purpose was generalized into: provide features that support developers managing complex software solutions. Now, it wasn't _just_ traits and concepts. **Philosoft** is also home to numerous attributes, both backports for older runtimes, and entirely new ones. This enables annotating almost anything you would need to, like nullability for better fault tolerance, or asymptotic complexity to help downstream make informed decisions about the performance curves of operations.