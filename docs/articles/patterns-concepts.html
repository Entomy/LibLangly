<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Patterns Concepts </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Patterns Concepts ">
    <meta name="generator" content="docfx 2.56.7.0">
    
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="patterns-concepts">Patterns Concepts</h1>

<p><strong>LibLangly's</strong> <em><strong>Patterns</strong></em> is a parsing engine with a radically different approach from what you're probably familiar with. It was primarily designed with reusability of patterns in mind, and general usability second. That being said, it happens to be extremely fast and lightweight, without being theory heavy.</p>
<p>It's also a CLS Compliant, cross language library, and will work on at least <a href="https://en.wikipedia.org/wiki/C_Sharp_%28programming_language%29">C#</a>, <a href="https://en.wikipedia.org/wiki/Visual_Basic_.NET">VisualBasic</a>, and <a href="https://en.wikipedia.org/wiki/F_Sharp_(programming_language)">F#</a>.</p>
<h2 id="pattern">Pattern</h2>
<p>Patterns form the base of this system. Similar to how patterns work in <strong>Regex</strong>, they represent what the parser will attempt to parse. However that's basically the end of the similarities.</p>
<p><code>Pattern</code> is a first class type. <code>Regex</code> lives inside of <a href="https://docs.microsoft.com/en-us/dotnet/api/system.string">String</a>. This has a major implication: You work with <code>Pattern</code> with whatever <a href="https://dotnet.microsoft.com/">.NET</a> language you feel like. You assign them to proper variables, and can combine them. No <a href="https://www.urbandictionary.com/define.php?term=copypasta">copypasta</a>.</p>
<p><code>Pattern</code> was designed for complex grammars. <code>Regex</code> was designed for <a href="https://en.wikipedia.org/wiki/Regular_language">regular languages</a>, one of the simpliest forms of language. This makes <code>Pattern</code> far more capable in what it can parse. In fact, the features of <strong>Patterns</strong> was designed around needing to parse complex languages like programming languages. As of <a href="https://github.com/Entomy/Stringier/commit/ad8fb5719d8e6c4a8843f2dc47385daba6270854">this commit</a> <code>Pattern</code> has provably supported right-recursion and mutual-recursion. And since parsers are separate from the pattern representation, a left-recursive supporting parser would be able to support left-recursion as well, but this hasn't been implemented yet.</p>
<h3 id="literal">Literal</h3>
<p>Literals in the context of <code>Pattern</code> are just like literals in your programming language. In fact, they are even the same thing.</p>
<div class="tabGroup" id="tabgroup_CeZOj-G++Q">
<ul role="tablist">
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q_cs" role="tab" aria-controls="tabpanel_CeZOj-G++Q_cs" data-tab="cs" tabindex="0" aria-selected="true">C#</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q_vb" role="tab" aria-controls="tabpanel_CeZOj-G++Q_vb" data-tab="vb" tabindex="-1">VB</a>
</li>
<li role="presentation">
<a href="#tabpanel_CeZOj-G++Q_fs" role="tab" aria-controls="tabpanel_CeZOj-G++Q_fs" data-tab="fs" tabindex="-1">F#</a>
</li>
</ul>
<section id="tabpanel_CeZOj-G++Q_cs" role="tabpanel" data-tab="cs">

<pre><code class="lang-csharp">Pattern ImplicitExample = &quot;Hello&quot;;
Pattern ExplicitExample = &quot;Hello&quot;.AsPattern();
</code></pre>
</section>
<section id="tabpanel_CeZOj-G++Q_vb" role="tabpanel" data-tab="vb" aria-hidden="true" hidden="hidden">

<pre><code class="lang-vbnet">Dim ImplicitExample As Pattern = &quot;Hello&quot;
Dim ExplicitExample As Pattern = &quot;Hello&quot;.AsPattern()
</code></pre>
</section>
<section id="tabpanel_CeZOj-G++Q_fs" role="tabpanel" data-tab="fs" aria-hidden="true" hidden="hidden">

<pre><code class="lang-fsharp">let example = p&quot;Hello&quot;;
</code></pre>
</section>
</div>

<p>We now have a pattern, named <code>Example</code>, which is literally <code>Hello</code>. On its own, this isn't very useful, but it does make for an efficient building block.</p>
<p>Whenever possible, an implicit conversion from <code>Char</code> or <code>String</code> to <code>Pattern</code> will occur. The exact rules about this will depend on your programming language. You may need to occasionally cast to <code>Pattern</code>, especially at the start of combinators of literals.</p>
<p>It's worth noting as an implementation detail, unlike <a href="https://en.wikipedia.org/wiki/Parser_combinator">Parser Combinators</a> like <a href="https://wiki.haskell.org/Parsec">parsec</a> or <a href="http://bennu-js.com/">Bennu</a> the base component is not a <code>Char</code>, but rather, any literal. There are literals defined for <code>Char</code> and <code>String</code>, as well as some advanced concepts that will be covered in later articles. This is extremely important for performance reasons, even though it's not obvious why. In the spirit of fairness, there are rare <a href="https://en.wikipedia.org/wiki/Parser_combinator">Parser Combinators</a> that do token based parsing (basically built up from <code>String</code>), such as <a href="https://github.com/datalust/superpower">Superpower</a>.</p>
<h3 id="modifier">Modifier</h3>
<p>Modifiers <em>modify</em> patterns. This includes concepts like making a pattern optional, or negating a pattern.</p>
<h3 id="combinator">Combinator</h3>
<p>Combinators <em>combine</em> patterns. This includes concepts like concatenation or alternates.</p>
<h2 id="source">Source</h2>
<p><code>Source</code> is a buffer that keeps track of the position during and after parsing operations. Importantly, it always reverts back to the starting position if a parse fails. This position is not manipulatable from code outside of the library, so there is no (easy) ability to tamper. (Abuse through reflection is technically always possible). New parsing operations always occur at the current position, so you don't need to manage anything. <code>Source</code> objects can be construction both from <code>Stream</code> and <code>String</code>, among others.</p>
<h2 id="result">Result</h2>
<p><code>Result</code> holds the result state of parser operations. It contains both the matched text, and a success/failure state. The exact implementation of these is subject to change, but this type will always be castable to <code>String</code> and <code>Boolean</code>, and if allowed, will implicitly convert to those types.</p>
<h2 id="parsers">Parsers</h2>
<p>Very unique to <strong>Patterns</strong> is multiple parsing models. Because my own needs are well met from a very particular set of parsers, I'm not focused on implementing as many as possible. However care was taken to keep the patterns purely descriptive, so that theoretically any parsing approach could be implemented.</p>
<h3 id="consume">Consume</h3>
<p>This parser tries to match the <code>Pattern</code> starting at the very beginning of the <code>Source</code> (or where it last left off), and returns a <code>Result</code>. It is naively like prefixing a <code>^</code> anchor to every <code>Regex</code>. This is generally the parser you want to use, as it parses from left to right in as obvious of a way as possible.</p>
<p>For the non-technically minded, this works as close to how you would normally read as possible, reading in your normal word order, and considering alternates in order.</p>
<p>For the technically minded, this seems to be closest to a PEG parser, although it wasn't designed with any particular grammar nor algorithm in mind, so this may not be 100% accurate. <code>Consume</code> definately considers the order important, however.</p>
<h3 id="others">Others</h3>
<p>There are other parsers planned, and I will do my best to maintain this documentation with new descriptions of them.</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/Entomy/LibLangly/blob/TraitTests/Documentation/articles/patterns-concepts.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
